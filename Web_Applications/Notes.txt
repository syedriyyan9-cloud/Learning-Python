- Virtual Environment is a space on your computer where you can install and isolate packages from other python packages.
- To activate V.E write name of the virtual environment\Scripts\activate in CMD
- To deactivate venv write deactivate in CMD
- Keep in mind that Django will be available only when the virtual environment is active.
- To create a new project in django use the following command: django-admin startproject project_name . (dot)
- Don’t forget this dot, or you might run into some configuration issues when you deploy the app.
- The settings.py file controls how Django interacts with your system and manages your project.
- The urls.py file tells Django which pages to build in response to browser requests.
- The wsgi.py file helps Django serve the files it creates. The filename is an acronym for web server gateway interface.
- Django stores most of the information for a project in a database, so next we need to create a database that Django can work with.
- To create a database we need to run the following command: py manage.py migrate
- Any time we modify a database, we say we’re migrating the database.
- Issuing the migrate command for the first time tells Django to make sure the database matches the current state of the project.
- Django reports that it will prepare the database to store information it needs to handle administrative and authentication tasks.
- SQLite is a database that runs off a single file; 
- it’s ideal for writing simple apps because you won’t have to pay much attention to managing the database.
- When we run the command: py manage.py runserver; django first check if the project is set up properly, then it reports the version of django in use and lastly it gives a url on which project is being served.
- Usually the project runs on localhost port 8000.
- Localhost refers to a server that only porcesses requests on your system, no one else has access to it.
- if django fails to run on port 8000 then change the port by writing, py manage.py runserver 8001; now the project is served on port 8001.
- Use the command python manage.py startapp app_name to create a django app.
- A model tells Django how to work with the data that will be stored in the app. Code-wise, a model is just a class; it has attributes and methods, just like every class we’ve discussed.
- The text attribute is a CharField—a piece of data that’s made up of characters, or text. You use CharField when you want to store a small amount of text, such as a name, a title, or a city. When we define a CharField attribute, we have to tell Django how much space it should reserve in the database.
- The date_added attribute is a DateTimeField—a piece of data that will record a date and time. We pass the argument auto_now_add=True, which tells Django to automatically set this attribute to the current date and time whenever the user creates a new topic.
- We tell Django which attribute to use by default when it displays information about a topic. Django calls a __str__() method to display a simple representation of a model. Here we’ve written a __str__() method that returns the string stored in the text attribute.
- The command: python manage.py makemigrations app_name tells Django to figure out how to modify the database so it can store the data associated with any new models we’ve defined.
- This migration will create a table for the model Topic in the database.
- To modify the database use the command: python manage.py migrate
- Whenever we want to modify the data that Learning Log manages, we’ll follow these three steps: modify models.py, call makemigrations on learning_logs, and tell Django to migrate the project.
- When we run the command: python manage.py createsuperuser, we are essentially creating an admin for our web application
- The code admin.site.register() tells Django to manage our model through the admin site
- A foreign key is a database term; it’s a reference to another record in the database.
- The on_delete=models.CASCADE argument tells Django that when a topic is deleted, all the entries associated with that topic should be deleted as well. This is known as a cascading delete.
- We nest the Meta class inside our Entry class. 
- The Meta class holds extra information for managing a model; here, it allows us to set a special attribute telling Django to use Entries when it needs to refer to more than one entry. Without this, Django would refer to multiple entries as Entrys.
- The command: python manage.py shell, run in an active virtual environment, launches a Python interpreter that you can use to explore the data stored in your project’s database.
- We then use the method Topic.objects.all() to get all the instances of the model Topic; the list that’s returned is called a queryset.
- We can loop over a queryset just as we’d loop over a list.
- If you know the ID of a particular object, you can use the method Topic.objects.get() to retrieve that object and examine any attribute the object has. 
- To get data through a foreign key relationship, you use the lowercase name of the related model followed by an underscore and the word 'set'
- Making web pages with Django consists of three stages: defining URLs,writing views, and writing templates. You can do these in any order, but in this project we’ll always start by defining the URL pattern. 
- A URL pattern describes the way the URL is laid out. 
- It also tells Django what to look for when matching a browser request with a site URL so it knows which page to return.
- Each URL then maps to a particular view—the view function retrieves and processes the data needed for that page. 
- The view function often renders the page using a template, which contains the overall structure of the page.
- To make it clear which urls.py we’re working in, we add a docstring at the beginning of the file. We then import the path function, which is needed when mapping URLs to views. 
- We also import the views module; the dot tells Python to import the views.py module from the same directory as the current urls.py module. 
- The variable app_name helps Django distinguish this urls.py file from files of the same name in other apps within the project. 
- The variable urlpatterns in this module is a list of individual pages that can be requested from the learning_logs app.
- The actual URL pattern is a call to the path() function, which takes three arguments. 
- The first argument is a string that helps Django route the current request properly. 
- Django receives the requested URL and tries to route the request to a view. 
- It does this by searching all the URL patterns we’ve defined to find one that matches the current request. 
- Django ignores the base URL for the project (http://localhost:8000/), so the empty string ('') matches the base URL. 
- Any other URL won’t match this pattern, and Django will return an error page if the URL requested doesn’t match any
existing URL patterns.
- The second argument in path() specifies which function to call in views.py. 
- When a requested URL matches the pattern we’re defining, Django calls the index() function from views.py (we’ll write this view function in the next section). 
- The third argument provides the name index for this URL pattern so we can refer to it in other code sections. 
- Whenever we want to provide a link to the home page, we’ll use this name instead of writing out a URL.
- A view function takes in information from a request (or takes in a request object), prepares the data needed to generate a page, and then sends the data back to the browser, often by using a template that defines what the page will look like.
- The template defines what the page should look like, and Django fills in the relevant data each time the page is requested. A template allows you to access any data provided by the view.
- Inside the learning_logs folder, make a new folder called templates. 
- Inside the templates folder, make another folder called learning_logs. 
- This might seem a little redundant (we have a folder named learning_logs inside a folder named templates inside a folder named learning_logs), but it sets up a structure that Django can interpret unambiguously, even in the context of a large project containing many individual apps.
- 